(*********************************************************************************)
(*                OCaml-R                                                        *)
(*                                                                               *)
(*    Copyright (C) 2008-2009 Institut National de Recherche en                  *)
(*    Informatique et en Automatique. All rights reserved.                       *)
(*                                                                               *)
(*    This program is free software; you can redistribute it and/or modify       *)
(*    it under the terms of the GNU General Public License as                    *)
(*    published by the Free Software Foundation; either version 3 of the         *)
(*    License, or  any later version.                                            *)
(*                                                                               *)
(*    This program is distributed in the hope that it will be useful,            *)
(*    but WITHOUT ANY WARRANTY; without even the implied warranty of             *)
(*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *)
(*    GNU Library General Public License for more details.                       *)
(*                                                                               *)
(*    You should have received a copy of the GNU General Public                  *)
(*    License along with this program; if not, write to the Free Software        *)
(*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA                   *)
(*    02111-1307  USA                                                            *)
(*                                                                               *)
(*    Contact: Maxence.Guesdon@inria.fr                                          *)
(*                                                                               *)
(*********************************************************************************)

(* This is the end of the Standard module, constructed via r.ml.part1 and .part2. *)
end

(** *)

external init_r : string array -> int = "init_r";;
external terminate : unit -> unit = "end_r";;

exception Initialisation_failed

let init ?(name = try Sys.argv.(0) with _ -> "OCaml-R")
         ?(argv = try List.tl (Array.to_list Sys.argv) with _ -> [])
         ?(env  = Standard.env) () =
  List.iter (function name, value -> Unix.putenv name value) env;
  match init_r (Array.of_list (name::argv)) with
  | 1 -> ()
  | _ -> raise Initialisation_failed
;;

type sexp
type langsxp (* We should perhaps make sexp a polymorphic type? *)
type symbol = string
type arg = [
    `Named of symbol * sexp
  | `Anon of sexp
  ]

external sexp : string -> sexp = "r_sexp_of_string"
external sexp_of_symbol : symbol -> sexp = "r_sexp_of_symbol"
external set_var : symbol -> sexp -> unit = "r_set_var"
external r_print_value : sexp -> unit = "r_print_value"

external langsxp_of_list : sexp list -> int -> langsxp = "langsxp_of_list"
external eval_langsxp : langsxp -> sexp = "r_eval_langsxp"
let eval = function l -> eval_langsxp (langsxp_of_list l (List.length l))
external exec : string -> arg array -> unit = "r_exec"

external to_bool : sexp -> bool = "bool_of_sexp"
external to_int : sexp -> int = "int_of_sexp"
external to_float : sexp -> float = "float_of_sexp"
external to_string : sexp -> string = "string_of_sexp"

external of_bool : bool -> sexp = "sexp_of_bool"
external of_int : int -> sexp = "sexp_of_int"
external of_float : float -> sexp = "sexp_of_float"
external of_string : string -> sexp = "sexp_of_string"

external to_bool_array : sexp -> bool array = "bool_array_of_sexp"
external to_int_array : sexp -> int array = "int_array_of_sexp"
external to_float_array : sexp -> float array = "float_array_of_sexp"
external to_string_array : sexp -> string array = "string_array_of_sexp"

external of_bool_array : bool array -> sexp = "sexp_of_bool_array"
external of_int_array : int array -> sexp = "sexp_of_int_array"
external of_float_array : float array -> sexp = "sexp_of_float_array"
external of_string_array : string array -> sexp = "sexp_of_string_array"

external get_attrib : sexp -> string -> sexp = "r_get_attrib"

let dim sexp = to_int_array (get_attrib sexp "dim");;
let dimnames sexp = to_string_array (get_attrib sexp "dimnames");;

(*
external to_matrix : (sexp -> 'a) -> sexp -> 'a array array = "to_matrix"
external of_matrix : ('a -> sexp) -> 'a array array -> sexp = "of_matrix"


let to_bool_matrix = to_matrix to_bool;;
let to_int_matrix = to_matrix to_int;;
let to_float_matrix = to_matrix to_float;;
let to_string_matrix = to_matrix to_string;;

let of_bool_matrix = of_matrix of_bool;;
let of_int_matrix = of_matrix of_int;;
let of_float_matrix = of_matrix of_float;;
let of_string_matrix = of_matrix of_string;;
*)

module type Interpreter = sig end

module Interpreter (Env : Environment) : Interpreter = struct
  let () = init ~name: Env.name ~argv: Env.options ~env: Env.env ()
end
